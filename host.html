<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P LLM Stream - Host</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    body {
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
    }
    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 30px;
    }
    .card {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      backdrop-filter: blur(10px);
    }
    .status {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f00;
    }
    .status-dot.connected {
      background: #0f0;
    }
    .status-dot.connecting {
      background: #ff0;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    #qr-container {
      text-align: center;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      display: inline-block;
    }
    #qr-code {
      width: 200px;
      height: 200px;
    }
    .room-id {
      font-family: monospace;
      background: rgba(0,0,0,0.3);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      word-break: break-all;
    }
    .stream-area {
      margin-top: 20px;
    }
    textarea {
      width: 100%;
      height: 150px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      color: #fff;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
    }
    textarea:focus {
      outline: none;
      border-color: #4CAF50;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    button.secondary {
      background: #2196F3;
    }
    button.secondary:hover {
      background: #1976D2;
    }
    .output {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      padding: 20px;
      min-height: 200px;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      text-align: center;
    }
    .stat {
      background: rgba(0, 0, 0, 0.2);
      padding: 15px;
      border-radius: 8px;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
    }
    .stat-label {
      font-size: 12px;
      color: #888;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåê P2P LLM Stream - Host</h1>
    <p class="subtitle">Generate a QR code for clients to join your session</p>

    <div class="card">
      <div class="status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-text">Disconnected</span>
        <span style="margin-left: auto; color: #888;" id="peer-count">0 peers</span>
      </div>
      
      <div style="text-align: center;">
        <button id="create-session" onclick="createSession()">Create Session</button>
        <button id="leave-session" onclick="leaveSession()" disabled class="secondary">Leave Session</button>
      </div>
    </div>

    <div class="card" id="qr-section" style="display: none;">
      <h3 style="margin-top: 0;">üì± Scan to Join</h3>
      <div style="text-align: center;">
        <div id="qr-container">
          <canvas id="qr-code"></canvas>
        </div>
        <p class="room-id" id="room-id"></p>
      </div>
    </div>

    <div class="card">
      <h3 style="margin-top: 0;">üìù LLM Text Input</h3>
      <p style="color: #888; font-size: 14px;">
        Paste or type text below. It will stream to connected clients in real-time.
      </p>
      <textarea id="llm-input" placeholder="Enter text to stream to clients..."></textarea>
      <div style="margin-top: 10px;">
        <button onclick="startStreaming()" id="start-btn">‚ñ∂Ô∏è Start Stream</button>
        <button onclick="stopStreaming()" id="stop-btn" disabled class="secondary">‚èπÔ∏è Stop Stream</button>
        <button onclick="simulateLLM()" id="simulate-btn">ü§ñ Simulate LLM</button>
      </div>
    </div>

    <div class="card">
      <h3 style="margin-top: 0;">üìä Statistics</h3>
      <div class="stats">
        <div class="stat">
          <div class="stat-value" id="token-count">0</div>
          <div class="stat-label">Tokens Sent</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="char-count">0</div>
          <div class="stat-label">Characters</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="sync-count">0</div>
          <div class="stat-label">Sync Events</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3 style="margin-top: 0;">üì§ Live Output</h3>
      <div class="output" id="output">Waiting for stream to start...</div>
    </div>
  </div>

  <script type="module">
    // Import from our modules
    import { 
      createConnectionManager,
      createSyncManager,
      createStreamHandler,
      createQRManager,
      createStorageAdapter,
      createDocumentStorage,
      generateRoomId,
      ConnectionState
    } from './src/index.js';
    
    // Import QRCode library and Trystero (using MQTT strategy for reliable connections)
    import QRCode from 'https://esm.sh/qrcode@1.5.3';
    import { joinRoom } from 'https://esm.sh/trystero/mqtt';

    // Initialize components
    const storageAdapter = createStorageAdapter(localStorage);
    const docStorage = createDocumentStorage(storageAdapter);
    const qrManager = createQRManager(QRCode);
    
    let connectionManager;
    let syncManager;
    let streamHandler;
    let currentRoomId = null;
    let syncCount = 0;

    // DOM elements
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const peerCount = document.getElementById('peer-count');
    const createBtn = document.getElementById('create-session');
    const leaveBtn = document.getElementById('leave-session');
    const qrSection = document.getElementById('qr-section');
    const qrCanvas = document.getElementById('qr-code');
    const roomIdEl = document.getElementById('room-id');
    const llmInput = document.getElementById('llm-input');
    const output = document.getElementById('output');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');

    // Update UI based on connection state
    function updateConnectionUI(state) {
      statusDot.className = 'status-dot';
      
      switch (state) {
        case ConnectionState.CONNECTED:
          statusDot.classList.add('connected');
          statusText.textContent = 'Connected';
          break;
        case ConnectionState.CONNECTING:
          statusDot.classList.add('connecting');
          statusText.textContent = 'Connecting...';
          break;
        case ConnectionState.ERROR:
          statusText.textContent = 'Error';
          break;
        default:
          statusText.textContent = 'Disconnected';
      }
    }

    // Create a new session
    window.createSession = async function() {
      try {
        // Initialize managers
        syncManager = createSyncManager({
          onTextChange: (text) => {
            output.textContent = text || 'Waiting for stream...';
            document.getElementById('char-count').textContent = text.length;
          }
        });

        connectionManager = createConnectionManager({
          onPeerJoin: (peerId) => {
            console.log('Peer joined:', peerId);
            peerCount.textContent = `${connectionManager.getPeerCount()} peer(s)`;
            // Send current state to new peer
            connectionManager.broadcast(syncManager.getState());
          },
          onPeerLeave: (peerId) => {
            console.log('Peer left:', peerId);
            peerCount.textContent = `${connectionManager.getPeerCount()} peer(s)`;
          },
          onStateChange: updateConnectionUI,
          onData: (data, peerId) => {
            syncCount++;
            document.getElementById('sync-count').textContent = syncCount;
          }
        });

        streamHandler = createStreamHandler(syncManager, connectionManager);

        // Generate room ID and join
        currentRoomId = generateRoomId();
        await connectionManager.join(currentRoomId, joinRoom);

        // Generate QR code
        await qrManager.generateToCanvas(qrCanvas, currentRoomId);
        roomIdEl.textContent = `Room: ${currentRoomId}`;

        // Update UI
        qrSection.style.display = 'block';
        createBtn.disabled = true;
        leaveBtn.disabled = false;

        // Save session
        docStorage.saveDocument(currentRoomId, { created: Date.now() });

      } catch (error) {
        console.error('Failed to create session:', error);
        alert('Failed to create session: ' + error.message);
      }
    };

    // Leave session
    window.leaveSession = function() {
      if (connectionManager) {
        connectionManager.leave();
      }
      qrSection.style.display = 'none';
      createBtn.disabled = false;
      leaveBtn.disabled = true;
      currentRoomId = null;
      peerCount.textContent = '0 peers';
      updateConnectionUI(ConnectionState.DISCONNECTED);
    };

    // Start streaming
    window.startStreaming = function() {
      if (streamHandler) {
        streamHandler.startStream();
        startBtn.disabled = true;
        stopBtn.disabled = false;
        output.textContent = '';
      }
    };

    // Stop streaming
    window.stopStreaming = function() {
      if (streamHandler) {
        streamHandler.stopStream();
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    };

    // Handle manual input
    let lastLength = 0;
    llmInput.addEventListener('input', () => {
      if (!streamHandler || !streamHandler.isActive()) return;
      
      const text = llmInput.value;
      if (text.length > lastLength) {
        const newText = text.slice(lastLength);
        streamHandler.onToken(newText);
        document.getElementById('token-count').textContent = streamHandler.getTokenCount();
      }
      lastLength = text.length;
    });

    // Simulate LLM streaming
    window.simulateLLM = async function() {
      if (!streamHandler) {
        alert('Please create a session first!');
        return;
      }

      startStreaming();
      
      const sampleText = `Hello! I'm an AI assistant demonstrating real-time P2P text streaming. 

This text is being sent through WebRTC directly to connected peers, with no central server involved. Each token is synchronized using CRDT-style conflict-free replication.

Key features:
‚Ä¢ Serverless P2P connection via Trystero
‚Ä¢ Real-time text synchronization
‚Ä¢ QR code session sharing
‚Ä¢ Browser-based storage

The connection uses Nostr relays for signaling, but all data transfer happens directly peer-to-peer after the initial handshake.`;

      const tokens = sampleText.split(/(?<=[ \n])/);
      
      for (const token of tokens) {
        if (!streamHandler.isActive()) break;
        
        streamHandler.onToken(token);
        document.getElementById('token-count').textContent = streamHandler.getTokenCount();
        llmInput.value += token;
        lastLength = llmInput.value.length;
        
        // Simulate typing delay
        await new Promise(r => setTimeout(r, 30 + Math.random() * 50));
      }

      stopStreaming();
    };
  </script>
</body>
</html>
